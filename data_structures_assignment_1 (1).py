# -*- coding: utf-8 -*-
"""data structures assignment 1

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1o2EQD9n-XWs4ZXrx26AJu_Ml5IO37nOm
"""

import random #importing random so I could shuffle and randomize the given chocolates

def Iterative(chocolates, students): #starting with the iterative function
    if len(chocolates) < len(students): #Using if statement to say that if the number of chocolates is less than number of students
        print("Not enough chocolates for each student.") #it would print not enough chocolates
        return

    random.shuffle(chocolates) #randomly shuffling the chocolates

    for i in range(len(students)): #using for loop so it would iterate over all the students and give them random chocolates
        print(f"{students[i]} : {chocolates[i]['type']} chocolate (weight: {chocolates[i]['weight']} gm, price: {chocolates[i]['price']} AED)") #printing the statement. i represents the random element in student and chocolate

def recursive(chocolates, students, idx=0): #recursive function
    if idx == len(students) or idx == len(chocolates): #this line checks if the index is equal to the length of students of chocolates by breaking them down into sub-problems so we could continue on with the process
        return

    random_index = random.randint(idx, len(chocolates) - 1) #randomizing the index and distribution process using random.randit
    chocolates[idx], chocolates[random_index] = chocolates[random_index], chocolates[idx]

    print(f"{students[idx]} : {chocolates[idx]['type']} chocolate (weight: {chocolates[idx]['weight']} gm, price: {chocolates[idx]['price']} AED)") #printing the fucntion with the weight and prices just like the iterative one

    recursive(chocolates, students, idx+1) #calling the function and making sure this statement conitnues and passes through all the students and chocolates

# Test cases
#iterative
chocolates = [
    {'type': 'milk chocolate', 'weight': 2, 'price': 4},
    {'type': 'caramel chocolate', 'weight': 3, 'price': 5},
    {'type': 'almond chocolate', 'weight': 4, 'price': 3},
    {'type': 'dark chocolate', 'weight': 5, 'price': 2},
    {'type': 'white chocolate', 'weight': 7, 'price': 1}
]

students = ['Noora', 'Hessa', 'Hind', 'Maryam', 'Aisha']

print("Iterative Distribution:")
Iterative(chocolates, students)

#recursive
chocolates = [
    {'type': 'milk chocolate', 'weight': 2, 'price': 4},
    {'type': 'caramel chocolate', 'weight': 3, 'price': 5},
    {'type': 'almond chocolate', 'weight': 4, 'price': 3},
    {'type': 'dark chocolate', 'weight': 5, 'price': 2},
    {'type': 'white chocolate', 'weight': 7, 'price': 1}
]

students = ['Noora', 'Hessa', 'Hind', 'Maryam', 'Aisha']

print("recursive Distribution:")
recursive(chocolates, students)

def merge_sort(chocolates, key='weight'): #using mergesort for the chocolates and using key to pick one of the attributes that I want which is weight
    if len(chocolates) <= 1: #using the if statement and checking if the length of the chocolates list is less than or equal to 1.
        return chocolates #it means there's only one chocolate or none, which is already sorted, so it returns the chocolates list

    mid = len(chocolates) // 2 #I calculated the midpoint index of the chocolates list to divide it into two halves for merge sort.
    left_half = merge_sort(chocolates[:mid], key) #calling the chocolates in a recursive order on the left side and stopping at the mid point
    right_half = merge_sort(chocolates[mid:], key) #calling the chocolates in a recursive order on the right side and stopping at the mid point

    return merge(left_half, right_half, key) #returning the function

def merge(left, right, key): #I will merge the left and right of the weight distribution after being sorted out
    result = [] #cretaing an empty list to store the merged result
    left_idx = right_idx = 0 #creating pointers for the left index and right index to track the current position in each list.

    while left_idx < len(left) and right_idx < len(right): #using while loop to compare all elements in the left and right till there's nothing left
        if left[left_idx][key] < right[right_idx][key]: #using if statement to compare the elements at the current positions of the weights of the left index and right index
            result.append(left[left_idx]) #if the element in the left list is smaller, it is appended to the result list
            left_idx += 1 #the left_idx pointer is incremented.
        else:
            result.append(right[right_idx]) #if the element in the right list is smaller or equal, it is appended to the result list
            right_idx += 1 #the right_idx pointer is incremented.

    result.extend(left[left_idx:]) #This line extends the result list by appending all the remaining elements from the left list to the end of the list.
    result.extend(right[right_idx:]) ##This line extends the result list by appending all the remaining elements from the right list to the end of the list.
    return result #returning the result list

# Sorting chocolates by weight and price
chocolates_sorted_by_weight = merge_sort(chocolates, 'weight')
chocolates_sorted_by_price = merge_sort(chocolates, 'price')

#test cases

# Printing chocolates sorted by weight
print("Chocolates sorted by weight:")
for chocolate in chocolates_sorted_by_weight: #for loop to iterate and print every weight of the chocolate
    print(f" {chocolate['type']}, Weight: {chocolate['weight']} gm")

# Printing chocolates sorted by price
print("Chocolates sorted by price:")
for chocolate in chocolates_sorted_by_price: #for loop to iterate and print every price of the chocolate
    print(f" {chocolate['type']}, Price: {chocolate['price']} AED")

def search_chocolate(students, chocolates, key, value): #using the search function for list students,  choclates and their key attributes which in this case would be weight and price and the specific value I'm searching for
    left = 0 #left side would be initialzied as 0
    right = len(chocolates) - 1 #right side would be the index of the last element in the chocolates list

    while left <= right: #while loop that continues as long as left is less than or equal to right to ensure space

        mid = (left + right) // 2 #Calculate the midpoint of the search space by adding the left and right side and dividing it by 2
        if chocolates[mid][key] == value: #using if statement to see that if the chocolate at the midpoint has the desired value for the specified key
            return students[mid] # return the corresponding student from the students list.
        elif chocolates[mid][key] < value: #if the value of the key for the chocolate at the midpoint is less than the desired value
            left = mid + 1 # search the right half of the remaining list.
        else: #If the value of the key for the chocolate at the midpoint is greater than the desired value
            right = mid - 1 # search the left half of the remaining list.

    return None #if the while loop exits without finding the desired value, return None


# Test Cases
chocolates = [
    {"type": "milk", "weight": 2, "price": 4},
    {"type": "caramel", "weight": 3, "price": 5},
    {"type": "almond", "weight": 4, "price": 3},
    {"type": "dark", "weight": 5, "price": 2},
    {"type": "white", "weight": 7, "price": 1}
]
students = ["Noora", "Hessa", "Hind", "Maryam", "Aisha"]

# Test searching by weight
weight_to_find = 3 #adding the specified weight value
student_with_weight = search_chocolate(students, chocolates, 'weight', weight_to_find)
print(f" {student_with_weight} is the student that is holding a chocolate with the weight of {weight_to_find} gm")

weight_to_find = 7
student_with_weight = search_chocolate(students, chocolates, 'weight', weight_to_find)
print(f" {student_with_weight} is the student that is holding a chocolate with the weight of {weight_to_find} gm")

# Test searching by price
price_to_find = 3 #adding the speicifed price value
student_with_price = search_chocolate(students, chocolates, 'price', price_to_find)
print(f" {student_with_price} is the student that is holding a chocolate with the price of {price_to_find} AED")

price_to_find = 0
student_with_price = search_chocolate(students, chocolates, 'price', price_to_find)
print(f" {student_with_price} is the student that is holding a chocolate with the price of {price_to_find} AED")